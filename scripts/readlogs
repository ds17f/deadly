#!/bin/bash

# readlogs - Unified cross-platform log reader for KMM development
# 
# Usage: readlogs [-a|-i] [-d|-i|-w|-e] [concept]
#
# Platform:
#   -a    Android logs (via adb logcat)
#   -i    iOS logs (via xcrun simctl or device logs)
#
# Level:
#   -d    Debug level logs
#   -i    Info level logs  
#   -w    Warning level logs
#   -e    Error level logs
#   (default: all levels)
#
# Concept Groups:
#   search    - Search functionality (SearchViewModel, SearchService, etc.)
#   di        - Dependency injection (Koin, modules)
#   ui        - UI interactions (App, navigation)
#   data      - Data import/export (DataImportService, ZipExtraction, etc.)
#   all       - All deadly app logs
#   [custom]  - Custom tag filter
#
# Examples:
#   readlogs -a -d search     # Android debug logs for search functionality
#   readlogs -i -e            # All iOS error logs
#   readlogs -a ui            # All Android UI logs

set -euo pipefail

# Script configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
APP_PACKAGE="com.grateful.deadly"

# Default values
PLATFORM=""
LOG_LEVEL=""
CONCEPT="all"
FOLLOW=false

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

usage() {
    cat << EOF
readlogs - Unified cross-platform log reader for KMM development

USAGE:
    readlogs [-a|-i] [-d|-i|-w|-e] [-f] [concept]

PLATFORM (required):
    -a          Android logs (via adb logcat)
    -i          iOS logs (via xcrun simctl)

LOG LEVEL (optional):
    -d          Debug level logs only
    -i          Info level logs only
    -w          Warning level logs only  
    -e          Error level logs only
    (default: all levels)

OPTIONS:
    -f          Follow logs (continuous tail)
    -h          Show this help

CONCEPT GROUPS:
    search      Search functionality (SearchViewModel, SearchService, etc.)
    di          Dependency injection (Koin, modules, application startup)
    ui          UI interactions (App, navigation, screens)
    data        Data import/export (DataImportService, ZipExtraction, etc.)
    icons       Cross-platform icon rendering
    logging     Logging system itself
    all         All deadly app logs (default)
    [custom]    Custom tag filter (exact match)

EXAMPLES:
    readlogs -a -d search               # Android debug logs for search
    readlogs -i -e                      # All iOS error logs  
    readlogs -a -f ui                   # Follow Android UI logs
    readlogs -i SearchViewModel         # iOS logs from SearchViewModel tag

NOTES:
    - Requires adb for Android logs (device/emulator connected)
    - Requires iOS Simulator for iOS logs
    - Use 'make android-run' or 'make ios-sim' to start apps before logging
    - Logs are colorized by level (Debug=Cyan, Info=Green, Warn=Yellow, Error=Red)
EOF
}

# Parse command line arguments
while getopts "aidhwef" opt; do
    case $opt in
        a) PLATFORM="android" ;;
        i) PLATFORM="ios" ;;
        d) LOG_LEVEL="debug" ;;
        w) LOG_LEVEL="warn" ;;
        e) LOG_LEVEL="error" ;;
        f) FOLLOW=true ;;
        h) usage; exit 0 ;;
        \?) echo "Invalid option: -$OPTARG" >&2; usage; exit 1 ;;
    esac
done

shift $((OPTIND-1))

# Get concept if provided
if [ $# -gt 0 ]; then
    CONCEPT="$1"
fi

# Validate required platform
if [ -z "$PLATFORM" ]; then
    echo -e "${RED}Error: Platform required. Use -a for Android or -i for iOS${NC}" >&2
    usage
    exit 1
fi

# Show available options if only platform specified (no concept)
if [ "$CONCEPT" = "all" ] && [ $# -eq 0 ]; then
    echo -e "${BLUE}ðŸ“± $PLATFORM platform selected${NC}"
    if [ -n "$LOG_LEVEL" ]; then
        echo -e "${BLUE}ðŸ” Log level: $LOG_LEVEL${NC}"
        echo -e "${YELLOW}Specify a concept to view logs:${NC}"
    else
        echo -e "${YELLOW}Available concept groups:${NC}"
    fi
    echo -e "  ${CYAN}search${NC}    - Search functionality (SearchViewModel, SearchService, etc.)"
    echo -e "  ${CYAN}di${NC}        - Dependency injection (Koin, modules, application startup)"
    echo -e "  ${CYAN}ui${NC}        - UI interactions (App, navigation, screens)"
    echo -e "  ${CYAN}data${NC}      - Data import/export (DataImportService, ZipExtraction, etc.)"
    echo -e "  ${CYAN}icons${NC}     - Cross-platform icon rendering"
    echo -e "  ${CYAN}logging${NC}   - Logging system itself"
    echo -e "  ${CYAN}all${NC}       - All deadly app logs"
    echo -e "  ${CYAN}[custom]${NC}  - Custom tag filter (exact match)"
    echo
    echo -e "${YELLOW}Usage examples:${NC}"
    if [ -n "$LOG_LEVEL" ]; then
        echo -e "  readlogs -$PLATFORM -$LOG_LEVEL search      # Show $LOG_LEVEL search logs"
        echo -e "  readlogs -$PLATFORM -$LOG_LEVEL ui          # Show $LOG_LEVEL UI logs"
        echo -e "  readlogs -$PLATFORM -$LOG_LEVEL all         # Show all $LOG_LEVEL logs"
    else
        echo -e "  readlogs -$PLATFORM search              # Show all search logs"
        echo -e "  readlogs -$PLATFORM -d ui               # Show debug UI logs only"
        echo -e "  readlogs -$PLATFORM -e                  # Show error logs from all concepts"
        echo -e "  readlogs -$PLATFORM -f search           # Follow search logs live"
    fi
    echo
    echo -e "${YELLOW}Use 'readlogs -h' for complete help${NC}"
    exit 0
fi

# Map concept to tag filters
get_tag_filters() {
    local concept="$1"
    case "$concept" in
        "search")
            echo "SearchViewModel|SearchScreen|SearchService"
            ;;
        "di")
            echo "KoinInitializer|DeadlyApplication|CommonModule|AndroidModule|IOSModule|Koin"
            ;;
        "ui")
            echo "App|SearchScreen|Navigation"
            ;;
        "data")
            echo "DataImportService|ZipExtractionService|ZipExtractor|FileDiscoveryService|DownloadService|JsonImportService|GitHubModels"
            ;;
        "icons")
            echo "AppIcon|IconRenderer"
            ;;
        "logging")
            echo "Logger"
            ;;
        "all")
            echo "$APP_PACKAGE"
            ;;
        *)
            # Custom tag - exact match
            echo "$concept"
            ;;
    esac
}

# Android log reading
read_android_logs() {
    local tag_filter="$1"
    local level_filter="$2"
    local follow_flag="$3"
    
    # Check if adb is available and device connected
    if ! command -v adb &> /dev/null; then
        echo -e "${RED}Error: adb not found. Install Android SDK platform tools.${NC}" >&2
        exit 1
    fi
    
    if ! adb devices | grep -q "device$"; then
        echo -e "${RED}Error: No Android device/emulator connected. Run 'make android-run' first.${NC}" >&2
        exit 1
    fi
    
    # Build adb logcat command
    local adb_cmd="adb logcat"
    
    # Add follow flag if needed
    if [ "$follow_flag" = true ]; then
        adb_cmd="$adb_cmd -v time"
    else
        adb_cmd="$adb_cmd -v time -d"  # -d = dump and exit
    fi
    
    # Add level filter if specified
    case "$level_filter" in
        "debug") adb_cmd="$adb_cmd *:D" ;;
        "info")  adb_cmd="$adb_cmd *:I" ;;  
        "warn")  adb_cmd="$adb_cmd *:W" ;;
        "error") adb_cmd="$adb_cmd *:E" ;;
        *)       adb_cmd="$adb_cmd *:V" ;;  # Verbose = all levels
    esac
    
    echo -e "${BLUE}ðŸ“± Reading Android logs for: ${CYAN}$tag_filter${NC}"
    if [ "$follow_flag" = true ]; then
        echo -e "${YELLOW}Press Ctrl+C to stop following logs${NC}"
    fi
    echo
    
    # Execute and filter
    if [ "$follow_flag" = true ]; then
        # For follow mode: show recent logs + follow new ones
        # Use unbuffered output to see logs immediately
        adb logcat -v time | grep --line-buffered -E "$tag_filter" | while IFS= read -r line; do
            # Colorize by log level
            if [[ "$line" =~ \ D\/ ]]; then
                echo -e "${CYAN}$line${NC}"
            elif [[ "$line" =~ \ I\/ ]]; then
                echo -e "${GREEN}$line${NC}"
            elif [[ "$line" =~ \ W\/ ]]; then
                echo -e "${YELLOW}$line${NC}"
            elif [[ "$line" =~ \ E\/ ]]; then
                echo -e "${RED}$line${NC}"
            else
                echo "$line"
            fi
        done
    else
        # For non-follow mode: just dump and exit
        $adb_cmd | grep -E "$tag_filter" | while IFS= read -r line; do
            # Colorize by log level
            if [[ "$line" =~ \ D\/ ]]; then
                echo -e "${CYAN}$line${NC}"
            elif [[ "$line" =~ \ I\/ ]]; then
                echo -e "${GREEN}$line${NC}"
            elif [[ "$line" =~ \ W\/ ]]; then
                echo -e "${YELLOW}$line${NC}"
            elif [[ "$line" =~ \ E\/ ]]; then
                echo -e "${RED}$line${NC}"
            else
                echo "$line"
            fi
        done
    fi
}

# iOS log reading  
read_ios_logs() {
    local tag_filter="$1"
    local level_filter="$2"
    local follow_flag="$3"
    
    # Check if xcrun is available
    if ! command -v xcrun &> /dev/null; then
        echo -e "${RED}Error: xcrun not found. Install Xcode command line tools.${NC}" >&2
        exit 1
    fi
    
    # Get booted simulator
    local sim_udid=$(xcrun simctl list devices | grep "Booted" | head -n1 | grep -o '[A-Z0-9-]\{36\}')
    
    if [ -z "$sim_udid" ]; then
        echo -e "${RED}Error: No iOS Simulator running. Run 'make ios-sim' first.${NC}" >&2
        exit 1
    fi
    
    echo -e "${BLUE}ðŸ“± Reading iOS Simulator logs for: ${CYAN}$tag_filter${NC}"
    if [ "$follow_flag" = true ]; then
        echo -e "${YELLOW}Press Ctrl+C to stop following logs${NC}"
    fi
    echo
    
    # Build log command - iOS logs are printed with our format
    local log_cmd="xcrun simctl spawn $sim_udid log stream"
    
    if [ "$follow_flag" = false ]; then
        # For non-follow mode, get recent logs
        log_cmd="xcrun simctl spawn $sim_udid log show --last 10m"
    fi
    
    # Execute and filter by our app and tag pattern
    $log_cmd --predicate 'processImagePath CONTAINS "Deadly"' 2>/dev/null | \
        grep -E "$tag_filter" | while IFS= read -r line; do
        
        # Colorize by our log format (D/, I/, W/, E/)
        if [[ "$line" =~ D/ ]]; then
            echo -e "${CYAN}$line${NC}"
        elif [[ "$line" =~ I/ ]]; then
            echo -e "${GREEN}$line${NC}"
        elif [[ "$line" =~ W/ ]]; then
            echo -e "${YELLOW}$line${NC}"
        elif [[ "$line" =~ E/ ]]; then
            echo -e "${RED}$line${NC}"
        else
            echo "$line"
        fi
        
        # Filter by level if specified
        case "$level_filter" in
            "debug") [[ "$line" =~ D/ ]] && echo -e "${CYAN}$line${NC}" ;;
            "info")  [[ "$line" =~ I/ ]] && echo -e "${GREEN}$line${NC}" ;;
            "warn")  [[ "$line" =~ W/ ]] && echo -e "${YELLOW}$line${NC}" ;;
            "error") [[ "$line" =~ E/ ]] && echo -e "${RED}$line${NC}" ;;
            *)       # Show all levels - already handled above
        esac
    done
}

# Main execution
main() {
    local tag_filter=$(get_tag_filters "$CONCEPT")
    
    echo -e "${MAGENTA}ðŸ” KMM Log Reader${NC}"
    echo -e "Platform: ${BLUE}$PLATFORM${NC}"
    echo -e "Level: ${BLUE}${LOG_LEVEL:-all}${NC}"
    echo -e "Concept: ${BLUE}$CONCEPT${NC}"
    echo -e "Filter: ${BLUE}$tag_filter${NC}"
    echo
    
    case "$PLATFORM" in
        "android")
            read_android_logs "$tag_filter" "$LOG_LEVEL" "$FOLLOW"
            ;;
        "ios")
            read_ios_logs "$tag_filter" "$LOG_LEVEL" "$FOLLOW"
            ;;
        *)
            echo -e "${RED}Error: Unknown platform '$PLATFORM'${NC}" >&2
            exit 1
            ;;
    esac
}

# Run main function
main "$@"